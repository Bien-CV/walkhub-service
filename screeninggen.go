package walkhub

import (
	"errors"

	"github.com/lib/pq"
	"github.com/tamasd/ab"
)

// AUTOGENERATED DO NOT EDIT

func NewScreening() *Screening {
	e := &Screening{}

	// HOOK: newScreening()

	return e
}

func EmptyScreening() *Screening {
	return &Screening{}
}

var _ ab.Validator = &Screening{}

func (e *Screening) Validate() error {
	var err error

	// HOOK: validateScreening()

	return err
}

func (e *Screening) GetID() string {
	return e.UUID
}

var ScreeningNotFoundError = errors.New("screening not found")

const screeningFields = "s.uuid, s.wid, s.uid, s.steps, s.created, s.published"

func selectScreeningFromQuery(db ab.DB, query string, args ...interface{}) ([]*Screening, error) {
	// HOOK: beforeScreeningSelect()

	entities := []*Screening{}

	rows, err := db.Query(query, args...)

	if err != nil {
		return entities, err
	}

	for rows.Next() {
		e := EmptyScreening()

		if err = rows.Scan(&e.UUID, &e.WID, &e.UID, &e.Steps, &e.Created, &e.Published); err != nil {
			return []*Screening{}, err
		}

		entities = append(entities, e)
	}

	// HOOK: afterScreeningSelect()

	return entities, err
}

func selectSingleScreeningFromQuery(db ab.DB, query string, args ...interface{}) (*Screening, error) {
	entities, err := selectScreeningFromQuery(db, query, args...)
	if err != nil {
		return nil, err
	}

	if len(entities) > 0 {
		return entities[0], nil
	}

	return nil, nil
}

func (e *Screening) Insert(db ab.DB) error {
	// HOOK: beforeScreeningInsert()

	err := db.QueryRow("INSERT INTO \"screening\"(wid, uid, steps, created, published) VALUES($1, $2, $3, $4, $5) RETURNING uuid", e.WID, e.UID, e.Steps, e.Created, e.Published).Scan(&e.UUID)

	// HOOK: afterScreeningInsert()

	return err
}

func (e *Screening) Update(db ab.DB) error {
	// HOOK: beforeScreeningUpdate()

	result, err := db.Exec("UPDATE \"screening\" SET wid = $1, uid = $2, steps = $3, created = $4, published = $5 WHERE uuid = $6", e.WID, e.UID, e.Steps, e.Created, e.Published, e.UUID)
	if err != nil {
		return err
	}

	aff, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return ScreeningNotFoundError
	}

	// HOOK: afterScreeningUpdate()

	return nil
}

func LoadScreening(db ab.DB, UUID string) (*Screening, error) {
	// HOOK: beforeScreeningLoad()

	e, err := selectSingleScreeningFromQuery(db, "SELECT "+screeningFields+" FROM \"screening\" s WHERE s.uuid = $1", UUID)

	// HOOK: afterScreeningLoad()

	return e, err
}

func LoadAllScreening(db ab.DB, start, limit int) ([]*Screening, error) {
	// HOOK: beforeScreeningLoadAll()

	entities, err := selectScreeningFromQuery(db, "SELECT "+screeningFields+" FROM \"screening\" s ORDER BY UUID DESC LIMIT $1 OFFSET $2", limit, start)

	// HOOK: afterScreeningLoadAll()

	return entities, err
}

type ScreeningService struct {
}

func (s *ScreeningService) Register(srv *ab.Server) error {
	var err error

	// HOOK: beforeScreeningServiceRegister()

	if err != nil {
		return err
	}

	afterScreeningServiceRegister(srv)

	return err
}

func screeningDBErrorConverter(err *pq.Error) ab.VerboseError {
	ve := ab.NewVerboseError(err.Message, err.Detail)

	// HOOK: convertScreeningDBError()

	return ve
}

func (s *ScreeningService) SchemaInstalled(db ab.DB) bool {
	found := ab.TableExists(db, "screening")

	// HOOK: afterScreeningSchemaInstalled()

	return found
}

func (s *ScreeningService) SchemaSQL() string {
	sql := "CREATE TABLE \"screening\" (\n" +
		"\t\"uuid\" uuid DEFAULT uuid_generate_v4() NOT NULL,\n" +
		"\t\"wid\" uuid NOT NULL,\n" +
		"\t\"uid\" uuid NOT NULL,\n" +
		"\t\"steps\" smallint NOT NULL,\n" +
		"\t\"created\" timestamp with time zone DEFAULT now() NOT NULL,\n" +
		"\t\"published\" bool NOT NULL,\n" +
		"\tCONSTRAINT screening_pkey PRIMARY KEY (uuid)\n);\n"

	sql = afterScreeningSchemaSQL(sql)

	return sql
}
